module Lab5 where

import Data.List
import System.Random
import Lecture5

{-
    Exercise 1:

    The goal of this exercise is to extend the Sudoku program described in the
    lecture of this week with functions that can also handle Sudokus of a special
    kind: the Sudokus that appear in the Dutch evening newspaper NRC-Handelsblad
    each week (designed by Peter Ritmeester, from Oct 8, 2005 onward). These NRC
    Sudokus are special in that they have to satisfy a few extra constraints: in
    addition to the usual Sudoku constraints, each of the 3×3 subgrids with
    left-top corner (2,2), (2,6), (6,2), and (6,6) should also yield an injective
    function. The above figure gives an example (this is the NRC sudoku that
    appeared Saturday Nov 26, 2005). Your task is to formalize this extra
    constraint, and to use your formalization in a program that can solve this
    Sudoku. See also the webpage of Andries Brouwer.

    Deliverables: modified Sudoku solver, solution to the above puzzle, indication of time spent.
-}

original :: Grid
original =
    [[0,0,0,3,0,0,0,0,0],
     [0,0,0,7,0,0,3,0,0],
     [2,0,0,0,0,0,0,0,8],
     [0,0,6,0,0,5,0,0,0],
     [0,9,1,6,0,0,0,0,0],
     [3,0,0,0,7,1,2,0,0],
     [0,0,0,0,0,0,0,3,1],
     [0,8,0,0,4,0,0,0,0],
     [0,0,2,0,0,0,0,0,0]]

uniqueSol' :: Node -> Bool
uniqueSol' node = singleton(take 2 (solveNs [node])) where
    singleton [] = False
    singleton [x] = True
    singleton [x,y] = False

{-
    Exercise 2:

    In order to refactor the code such that the formulation of constraints
    becomes more uniform, the following definitions were proposed:

    > type Position = (Row,Column)
    > type Constrnt = [[Position]]

    The regular constraints for Sudoku can now be stated as:

    > rowConstrnt = [[(r,c)| c <- values ] | r <- values ]
    > columnConstrnt = [[(r,c)| r <- values ] | c <- values ]
    > blockConstrnt = [[(r,c)| r <- b1, c <- b2 ] | b1 <- blocks, b2 <- blocks ]

    The generation of the values that are still possible at a given position now
    takes the following shape:

    > freeAtPos' :: Sudoku -> Position -> Constrnt -> [Value]
    > freeAtPos' s (r,c) xs = let
    >    ys = filter (elem (r,c)) xs
    >  in
    >    foldl1 intersect (map ((values \\) . map s) ys)

    Refactor the code along the lines of this proposal, and next compare the two
    versions for extendability and efficiency. Which of the two versions is easier
    to modify for NRC sudokus, and why? Which of the two versions is more efficient?
    Devise your own testing method for this, and write a short test report.

    Deliverables: Refactored code, test report, indication of time spent.
-}

{-
    Exercise 3:

    A Sudoku problem P is minimal if it admits a unique solution, and every
    problem P' you can get from P by erasing one of the hints admits more than
    one solution. How can you test whether the problems generated by the code
    given in the lecture notes are minimal?

    Deliverables: testing code, test report, indication of time spent.
-}

-- By definition of a minimal sudoku, we generate a list of all the positions that
-- are filled in the original sudoku. Then we run the previous function to see if
-- by removing that number multiple functions arise.
-- Helper function that prints the amount of solutions for a certain grid (maxed out at 10.)
printSolutions :: Grid -> IO Int
printSolutions gr = do
    if not (longerThan 10 (solveNs (initNode gr)))
        then return $ length(solveNs (initNode gr))
        else return 1000000

-- Bool to test if there is 1 solution to a sudoku.
testMinimalism :: Grid -> Bool
testMinimalism gr = not (longerThan 1 (solveNs (initNode gr))) &&
                    length (solveNs (initNode gr)) == 1

-- Functions to check if a list is longer than a certain amount of elements.
-- Using instead of length :: https://stackoverflow.com/questions/7371730/how-to-tell-if-a-list-is-infinite
isNonEmpty :: [a] -> Bool
isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -> [a] -> Bool
longerThan n xs = isNonEmpty $ drop n xs

check :: Sudoku -> [(Row,Column)] -> Bool
check sud [] = True
check sud (x:xs) = not (testMinimalism(sud2grid(eraseS sud x))) && check sud xs

checkMinimalismLessHints :: Grid -> Bool
checkMinimalismLessHints gr = check sud (filledPositions sud)
    where sud = grid2sud gr

testCheck :: IO Bool
testCheck = do
    [sud] <- rsolveNs [emptyN]
    minSud  <- genProblem sud
    return $ checkMinimalismLessHints (sud2grid (fst minSud))
    -- I used Anna's mind.


{-
    Exercise 4:

    Write a program that generates Sudoku problems with three empty blocks.
    Is it also possible to generate Sudoku problems with four empty blocks?
    Five? How can you check this?

    Deliverables: generator, short report on findings, indication of time spent.
-}

--list with all the positions
allPositions = [(r,c) | r <- [1..9], c <- [1..9]]

deleteBlock :: Node -> (Row,Column) -> Node
deleteBlock n (r,c) = foldr (\rc n' -> eraseN n' rc) n (sameBlock (r,c))

--list with all the positions which are included in a subgrid (given one position of this subgrid)
sameBlock :: (Row, Column) -> [(Row, Column)]
sameBlock (r,c) = [(x,y)| x <- bl r, y<- bl c]

--check if the subgrids of two positions are in the same row or column
--we don't want the three empty subgrids to be all in the same row or column
checkRC :: (Row, Column) -> (Row, Column) ->Bool
checkRC a b = (bl (fst a) /= bl (fst b) && bl (snd a) /= bl (snd b))

-- We choose 3 random positions. We make sure that they are in different subgrids and that their subgrids
-- are not all in the same row or column.
-- We delete the 3 subgrids in which our positions are included
deleteBlocks :: Node -> IO Node
deleteBlocks n = do list1 <- randomize allPositions
                    let delBlock1 = head list1
                    let list2 =  [a | a <- list1, not (a `elem` (sameBlock delBlock1))]
                    let delBlock2 = head list2
                    let list3 =  [a | a <- list2, not (a `elem` (sameBlock delBlock2)), (checkRC a delBlock2) || (checkRC a delBlock1)]
                    let delBlock3 = head list3
                    let delBlockList = [delBlock1,delBlock2,delBlock3]
                    let newNode = foldr (\b n' -> deleteBlock n' b) n delBlockList
                    return newNode


--commented the two lines. To discuss what is a better solution!
--This way we generate sudokus with ONLY 3 blocks empty and all the other positions filled
--If i uncomment them we generate sudokus with 3 empty blocks and other empty positions as well
randomSudoku :: IO ()
randomSudoku = do [r] <- rsolveNs [emptyN]
                  showNode r
                  sudokuEmptyblocks <- deleteBlocks r
                  s <- genProblem sudokuEmptyblocks
                  showNode s
                  -- showNode sudokuEmptyblocks


{-
    Exercise 5:

    Extend the code of the lectures to create a program that generates NRC
    Sudoku problems, that is, Sudoku problems satisfying the extra constraint
    explained in the NRC exercise above.

    Deliverables: NRC Sudoku generator, indication of time spent.
-}

-- I created a prime functions for all functions that use the prune function
-- and Anna added the constraint for NRC sudokus to the prune function.
-- The generator will call these functions eventually and instead of generate
-- a regular sudoku, it will generate one that adheres to the NRC constraints.
prune' :: (Row,Column,Value) -> [Constraint] -> [Constraint]
prune' _ [] = []
prune' (r,c,v) ((x,y,zs):rest)
    | r == x = (x,y,zs\\[v]) : prune' (r,c,v) rest
    | c == y = (x,y,zs\\[v]) : prune' (r,c,v) rest
    | sameblock (r,c) (x,y) =
        (x,y,zs\\[v]) : prune' (r,c,v) rest
    | newsameblock (r,c) (x,y) =
        (x,y,zs\\[v]) : prune' (r,c,v) rest--added/ checks newsameblock
    | otherwise = (x,y,zs) : prune' (r,c,v) rest

search' :: (node -> [node])
       -> (node -> Bool) -> [node] -> [node]
search' children goal [] = []
search' children goal (x:xs)
  | goal x    = x : search' children goal xs
  | otherwise = search' children goal ((children x) ++ xs)

solveNs' :: [Node] -> [Node]
solveNs' = search' succNode' solved

succNode' :: Node -> [Node]
succNode' (s,[]) = []
succNode' (s,p:ps) = extendNode' (s,ps) p

extendNode' :: Node -> Constraint -> [Node]
extendNode' (s,constraints) (r,c,vs) =
   [(extend s ((r,c),v),
     sortBy length3rd $
         prune' (r,c,v) constraints) | v <- vs ]


rsuccNode' :: Node -> IO [Node]
rsuccNode' (s,cs) = do
    xs <- getRandomCnstr cs
    if null xs then return [] else return (extendNode' (s,cs\\xs) (head xs))

rsolveNs' :: [Node] -> IO [Node]
rsolveNs' ns = rsearch rsuccNode' solved (return ns)

-- This generates a solved sudoku NRC style
genRandomNRCSudoku :: IO Node
genRandomNRCSudoku = do
    [r] <- rsolveNs' [emptyN]
    return r

-- This function minimizes the solved sudoku in order to make it a sudoku puzzle.
genNRCProblem :: IO Node
genNRCProblem = do
    x <- genRandomNRCSudoku
    x' <- genProblem x
    return x'

{-
    Exercise 6 (Bonus):

    Can you find a way of classifying the difficulty of a Sudoku problem? Can
    you modify the Sudoku problem generator so that it can generate problems
    that are minimal, but easy to solve by hand? Problems that are minimal but
    hard to solve by hand? How can you test whether the problems your program
    generates satisfy these properties? Consult (Pelánek 2014).
-}

{-
    Exercise 7 (Bonus):

    Minimal problems for NRC Sudokus need fewer hints than standard Sudoku problems.
    Investigate the difference. What is the average number of hints in a minimal
    standard Sudoku problem? What is the average number of hints in a minimal NRC
    Sudoku problem?
-}
